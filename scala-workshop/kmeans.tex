\section{Distributed \kmeans Clustering}
\label{sec:kmeans}

The K-Means benchmark uses Lloyd's algorithm~\cite{Lloyd1982Least} to divide a set of points in a $d$-dimensional space into $k$ disjoint clusters.
Given an arbitrary set of initial clusters, the algorithm iterates over the following steps:
\begin{enumerate}
  \item For each point, assign that point to whichever cluster is closest (by Euclidean distance to the cluster centroid).
  \item For each cluster, update the centroid (the arithmetic mean of all points in that cluster).
\end{enumerate}

Cluster contributions may be computed in parallel for each point, with two collective reductions across all processes to compute new cluster centroids.

Problem definition. Why it's ``easy'' to distribute.

Contrast with actors: messaging and communication is implicit vs. explicit.

Shared memory is not idiomatic in Akka, whereas embraced in APGAS. Ex: updating
the central array. This means we end up with code that requires concurrency
control.

Here we just used \lstinline{synchronized}. If Java had a proper
implementation or arrays with atomic increments for floats (analogous to
\lstinline{AtomicIntegerArray}), we could also just use that.
